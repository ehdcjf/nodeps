# 15841

dp[i]: i는 시간, dp[i]는 i시간에 죽일 소

조건식
dp[i] = dp[i-1]+ dp[i-1] (i>2);

초기 값
dp[1] = 1;
dp[2] = 1;

주의 사항
BigInt

# 26529

dp[i]는 i달 후 토끼의 수

조건식
dp[i] = dp[i-1]+ dp[i-1] (i>1);

초기값
dp[0] = 1;
dp[1] = 1;

# 2775

dp[i][j]는 i층 j호에 거주하는 거주민

조건식
dp[i][j] = dp[i-1][j] + dp[i][j-1] (i>0, j>0)

초기값
dp[0] = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
dp[n][0] = 1;

# 24416 알고리즘 수업 - 피보나치 수 1

이건 그냥 재귀로 구현하라는 문제;;

# 1010 다리 놓기

dp[i][j] 동쪽 i 개 사이트에서 서쪽 j개 사이트에 지을 수 있는 다리의 경우의 수

초기값
dp[i][1] = 1;
dp[1][j] = j;

# 9625 BABBA

dp[i][a] 는 버튼을 i번 눌렀을 때, A의 개수
dp[i][b] 는 버튼을 i번 눌렀을 때, B의 개수

조건식
dp[i][a] = dp[i-1][b] (i>0);
dp[i][b] = dp[i-1][a] + dp[i-1][b] (i>0);

초기값
dp[0]=[1,0]

# 10826 피보나치 수 4

그냥 피보나치 + BigInt

# 13301 타일 장식물

피보나치 + BigInt
직사각형의 둘레는 dp[i] x 4 + dp[i-1] x 2

# 16359 파스칼의 삼각형

파스칼 삼각형의 n행 k열에 있는 수는
dp[n-k+1][k]

조건식
dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

초기값
dp[][1] = 1;
dp[1][] = 1;

# 14606 피자(Small)

dp[i] 는 피자 판이 i개 있을 때 느낄 수 있는 즐거움의 총합

조건식
dp[i] = Math.floor(i/2) \* (i-Math.floor(i/2)) + dp[Math.floor(i/2)] + dp[(i-Math.floor(i/2))]

초기값
dp[1] = 0
dp[2] = 1

# 19947 투자의 귀재 배주형

dp[i] 는 i년 투자했을 때 최대 금액

조건식
eja[] = [null, 1.05, null, 1.2, null, 1.35]
dp[i] = max(dp[i], dp[i-j] \* eja[j])

j = 1 또는 3 또는 5
i-j>=0 일때만 계산

초기값
dp[0]=H(원금)

# 2491 수열

increment[i] 는 arr[i] 로 끝나는 수열 중 가장 긴 증가하는 구간의 길이
decrement[i] 는 arr[i] 로 끝나는 수열 중 가장 긴 감소하는 구간의 길이

초기값
increment[n]=1;
decrement[n]=1;

# 11048 이동하기

memo[i][j] 는 (i,j)까지 이동했을 때 얻을 수 있는 사탕의 최대 개수

조건식

memo[i][j] = max(memo[i][j - 1], memo[i - 1][j], memo[i - 1][j - 1]) + (i,j)에 있는 사탕의 개수

초기값
memo[n][m] = 0; (0<=n<=N , 0<=m<=M)

# 9657 돌 게임 3

dp[i] 는 돌이 i 개 있을 때, 완벽하게 게임을 했을 때, 게임의 승자

dp[i] 가 true 면 상근이 승리
dp[i] 가 false 면 창영이 승리

조건식
dp[i] = !dp[i-1] || !dp[i-3] || !dp[i-4]

dp[i-1] 은 돌이 i-1 개 있을 때 마지막으로 돌을 가져간 사람.
그리고 1개를 다음 사람이 가져가고, 그사람이 이기게 됨. => !dp[i-1]

1,3,4 세가지 경우를 고려하여 셋 중 하나라도 상근이가 이길 수 있는 경우가 있다면.
상근은 해당 경우를 선택.

초기값
dp[1] = true(SK)
dp[2] = false(CY)
dp[3] = true(SK)
dp[4] = true(SK)

# 9658 돌게임 2

dp[i] 는 돌이 i 개 있을 때, 완벽하게 게임을 했을 때, 게임의 승자

dp[i] 가 true 면 상근이 승리
dp[i] 가 false 면 창영이 승리

조건식
dp[i] = !dp[i-1] || !dp[i-3] || !dp[i-4]

초기값
dp[1] = false(CY)
∵ sk1 => cy win

dp[2] = true(SK)  
∵ sk1-cy1 => sk win

dp[3] = false(CY)
∵ sk1-cy1-sk1 => cy win
∵ sk3 => cy win

dp[4] = true(SK)
∵ sk4 => cy win
∵ sk3 cy1 => sk win

# 9661 돌게임 7

dp[i] 는 돌이 i 개 있을 때, 완벽하게 게임을 했을 때, 게임의 승자

조건식
dp[i] = dp[i] || dp[i-4^n]  
n 은 0부터 4^n< i 인 정수

초기값

dp[1] = true(SK)
dp[2] = false(CY)
dp[3] = true(SK)
dp[4] = true(SK)

이렇게 dp 돌린다음에 규칙 찾기
1 2 3 4 5
6 7 8 9 10
sk cy sk sk cy

# 9465 스티커

dp[i][0] 는 i번쨰 열의 첫번쨰 행 스티커까지 뜯었을 때 얻을 수 있는 최대 점수
dp[i][1] 는 i번쨰 열의 두번쨰 행 스티커까지 뜯었을 때 얻을 수 있는 최대 점수
dp[i][2] 는 i번쨰 열의 스티커를 하나도 떼지 않았을 때 최대 점수

조건식
dp[i][0] = board[0][i] + max(dp[i-1][1], dp[i-1][2])
dp[i][1] = board[1][i] + max(dp[i-1][0], dp[i-1][2])
dp[i][0] = max(dp[i-1][0], dp[i-1][1], dp[i-1][2])

# 15486 퇴사 2

dp[i] 는 i일에 얻을 수 있는 최대 수익.

상담 종료일이 퇴사일 보다 늦는다면 상담할 수 없음
=> 뒤에서 부터 계산하기로 함.

위와 같은 이유로 상담을 못한다면.......
i일에 얻을 수 있는 최대 수익은 i+1일에 얻을 수 있는 최대 수익과 같음.
왜냐하면.. 어차피 내가 일하는 기간은 고정적이기 때문.

i일에 출근을 하든, 결근을 하든
적어도 그 다음날에 벌 수 있는 최대 금액은 벌 수 있다는 거임.

간단하게

i 1|2|3
T 1|1|1
P 1|1|1

이라고 했을때, 뒤에서부터 내가 돈을 얼마나 벌 수 있는지 생각해보면.

3일에 일을 해서 1을 얻을 수 있다고 했을 때...
최대 수익을 찾는 거니까..
2일에 무슨 일이 생겨서 출근을 안하던 최소한 3일에 번거
만큼은 벌 수 잇음.
그러니까

dp[i] = dp[i+1]

상담이 가능하면.
상담을 하는 경우, 하지 않는 경우. 두 가지 경우를 고려해야함. 왜냐하면 어떤 날 상담을 하는 경우. 그 상담 기간이 길어진다면 그 상담을 시작 하는 것이. 다른 날 상담을 하는 것에 비해 손해이기 때문.

i 1|2| 3
T 1|2| 1
P 1|1|100

이렇게 2일에 일을 하면 3일에 일을 못해서 손해임.

그러니까 상담을 하는 경우. 안하는 경우를 고려해서
그 비용을 계산해서 돈을 많이 벌 수 있는 경우를 선택해야함.

일을 한다면.

work = P[i] + dp[i+T[i]]

그날 상담이 끝나고 바로 시작할 수 있는 상담일에서의 최대 수익을 더해야함.

일을 안한다면.
위에랑 똑같음. 다음날 얻을 수 있는 수익이 오늘 얻을 수 있는 수익의 최소값이 됨.

dp[i] = max(work, dp[i+1]);

초기값 dp[i] = 0;

# 9084 동전

2293 동전1 이랑 같은 문제

dp[i] = i원을 만들 수 있는 경우의 수

조건식
coin.forEach((v) => {
for (let i = v; i <= k; i++) {
dp[i] += dp[i - v];
}
});

초기값
dp[0] = 1;
dp[n] = 0; (n>0)
